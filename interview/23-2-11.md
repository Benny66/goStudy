1.go是引用传递和值传递？
- 值传递

2.go是否支持泛型
- 支持

3.go csp并发模型
- CSP的理念：以通信的方式来共享内存，即“不要通过共享内存来通信，而要通过通信来实现内存共享”，基于channel实现。

4.go协程调度
GMP协程调度
 - G就是协程,拥有运行函数的指针、栈、上下文
 - P就是调度器：每一个调度器都有一个本地队列，里面是待执行的G，如果队列里没有G就会去全局队列里拿G执行，如果全局队列中没有，就回去别的P那里抢G执行
 - M就是用来与P绑定执行G中任务

5.go窃取原理
p的调度分类
- 主动调度：协程通过runtime.Goshed主动的让渡自己执行的权利（自己不想干给别人干）
- 被动调度：协程休眠，通道堵塞等会被动的让渡自己执行的权利，（自己干不动，给别人干）
- 抢占式调度：


6.go的垃圾回收gc原理
- 三色标级法

7.go的逃逸分析
栈，堆
逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为，编译阶段确立逃逸

常见的内存逃逸有：
- 函数方法内返回指针
- interface{}，fmt.Println()不确定参数类型，运行才知道
- 栈空间不足逃逸，切片扩容
- 在切片上存储指针或带有指针的值
- 发送指针或者带有指针的数据进channel

总结：分配到堆上情况包含：全局的，不确定大小的，空间不够

8.go的内存泄漏
- pprof

9.new和make的区别？

10.defer的使用？

11.map并发安全吗？如何解决并发安全

12.map的key是否有序，如何进行排序？

13.数组和切片的区别？

14.slice的扩容

15.channel有无缓冲的区别

16.init函数的引用和使用

17.go语言的select用于解决什么问题？

18.go协程并发控制的三种方式？
- WaitGroup：多个goroutine的任务处理存在依赖或拼接关系。
- channel+select：可以主动取消goroutine；多groutine中数据传递；
- context上下文：多层级groutine之间的信号传播

19.go使用空的struct有什么好处
- 空结构体，占位符，不分配内存

20.go中interface的使用
- eface:没有任何方法的接口
- iface：有方法的接口

eface的结构包含：*_type和unsafe.Pointer
iface的结构包含：*itab和unsafe.Pointer
 - *itab主要包含：*intefacetype,*_type,func方法集
21.sync.RWmutex和sync.Mutex的区别和使用场景

22.go中gc的触发条件

23.go项目如何进行平滑重启

24.如何跳出for select 的循环体